{"version":3,"file":"xmlParser.js","sourceRoot":"","sources":["../src/xmlParser.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAkBA,8DA0EC;AA4FD,kDAuDC;AAMD,gDAuDC;AA5SD,+CAAiC;AAcjC;;;GAGG;AACH,SAAgB,yBAAyB,CACvC,QAA6B,EAC7B,QAAyB;IAEzB,MAAM,IAAI,GAAG,QAAQ,CAAC,OAAO,EAAE,CAAC;IAChC,MAAM,MAAM,GAAG,QAAQ,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC;IAE3C,OAAO,CAAC,GAAG,CAAC,2CAA2C,MAAM,UAAU,QAAQ,CAAC,IAAI,UAAU,QAAQ,CAAC,SAAS,EAAE,CAAC,CAAC;IAEpH,yDAAyD;IACzD,MAAM,IAAI,GAAG,YAAY,CAAC,IAAI,CAAC,CAAC;IAEhC,iDAAiD;IACjD,+EAA+E;IAC/E,6EAA6E;IAC7E,MAAM,KAAK,GAAiB,EAAE,CAAC;IAC/B,IAAI,UAAoC,CAAC;IAEzC,KAAK,MAAM,GAAG,IAAI,IAAI,EAAE,CAAC;QACvB,IAAI,GAAG,CAAC,SAAS,EAAE,CAAC;YAClB,sCAAsC;YACtC,IAAI,KAAK,CAAC,MAAM,GAAG,CAAC,IAAI,KAAK,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,IAAI,KAAK,GAAG,CAAC,IAAI,EAAE,CAAC;gBAClE,KAAK,CAAC,GAAG,EAAE,CAAC;YACd,CAAC;QACH,CAAC;aAAM,IAAI,GAAG,CAAC,aAAa,EAAE,CAAC;YAC7B,wDAAwD;YACxD,IAAI,MAAM,IAAI,GAAG,CAAC,MAAM,IAAI,MAAM,IAAI,GAAG,CAAC,MAAM,GAAG,GAAG,CAAC,IAAI,CAAC,MAAM,EAAE,CAAC;gBACnE,MAAM,OAAO,GAAe;oBAC1B,IAAI,EAAE,GAAG,CAAC,IAAI;oBACd,UAAU,EAAE,GAAG,CAAC,UAAU;oBAC1B,WAAW,EAAE,GAAG,CAAC,MAAM;oBACvB,SAAS,EAAE,GAAG,CAAC,MAAM,GAAG,GAAG,CAAC,IAAI,CAAC,MAAM;oBACvC,SAAS,EAAE,GAAG,CAAC,IAAI;oBACnB,WAAW,EAAE,GAAG,CAAC,MAAM;iBACxB,CAAC;gBACF,4EAA4E;gBAC5E,UAAU,GAAG,CAAC,GAAG,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,GAAG,CAAC,EAAE,CAAC,CAAC,EAAE,OAAO,CAAC,CAAC;YACxD,CAAC;QACH,CAAC;aAAM,CAAC;YACN,cAAc;YACd,MAAM,OAAO,GAAe;gBAC1B,IAAI,EAAE,GAAG,CAAC,IAAI;gBACd,UAAU,EAAE,GAAG,CAAC,UAAU;gBAC1B,WAAW,EAAE,GAAG,CAAC,MAAM;gBACvB,SAAS,EAAE,CAAC,CAAC,EAAE,4CAA4C;gBAC3D,SAAS,EAAE,GAAG,CAAC,IAAI;gBACnB,WAAW,EAAE,GAAG,CAAC,MAAM;aACxB,CAAC;YAEF,oDAAoD;YACpD,IAAI,MAAM,IAAI,GAAG,CAAC,MAAM,IAAI,MAAM,IAAI,GAAG,CAAC,MAAM,GAAG,GAAG,CAAC,IAAI,CAAC,MAAM,EAAE,CAAC;gBACnE,UAAU,GAAG,CAAC,GAAG,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,GAAG,CAAC,EAAE,CAAC,CAAC,EAAE,OAAO,CAAC,CAAC;YACxD,CAAC;YAED,iDAAiD;YACjD,KAAK,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;QACtB,CAAC;IACH,CAAC;IAED,uFAAuF;IACvF,IAAI,CAAC,UAAU,IAAI,KAAK,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;QACpC,8DAA8D;QAC9D,KAAK,IAAI,CAAC,GAAG,KAAK,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC,IAAI,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC;YAC3C,IAAI,MAAM,IAAI,KAAK,CAAC,CAAC,CAAC,CAAC,WAAW,EAAE,CAAC;gBACnC,UAAU,GAAG,KAAK,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,GAAG,CAAC,EAAE,CAAC,CAAC,CAAC;gBACxD,MAAM;YACR,CAAC;QACH,CAAC;IACH,CAAC;IAED,MAAM,IAAI,GAAG,UAAU,IAAI,EAAE,CAAC;IAE9B,OAAO,CAAC,GAAG,CAAC,iCAAiC,IAAI,CAAC,MAAM,cAAc,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC;IAC3G,OAAO,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,SAAS,CAAC;AAC5C,CAAC;AAaD;;GAEG;AACH,SAAS,YAAY,CAAC,IAAY;IAChC,MAAM,IAAI,GAAc,EAAE,CAAC;IAE3B,mEAAmE;IACnE,yDAAyD;IACzD,MAAM,QAAQ,GAAG,sDAAsD,CAAC;IAExE,IAAI,KAA6B,CAAC;IAClC,IAAI,IAAI,GAAG,CAAC,CAAC;IACb,IAAI,SAAS,GAAG,CAAC,CAAC;IAElB,OAAO,CAAC,KAAK,GAAG,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,KAAK,IAAI,EAAE,CAAC;QAC9C,MAAM,SAAS,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;QAC3B,MAAM,eAAe,GAAG,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAE,yBAAyB;QAC9D,MAAM,mBAAmB,GAAG,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAE,2BAA2B;QACpE,MAAM,OAAO,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;QACzB,MAAM,UAAU,GAAG,KAAK,CAAC,CAAC,CAAC,IAAI,EAAE,CAAC;QAClC,MAAM,MAAM,GAAG,KAAK,CAAC,KAAK,CAAC;QAE3B,4BAA4B;QAC5B,OAAO,SAAS,GAAG,IAAI,CAAC,MAAM,IAAI,SAAS,IAAI,MAAM,EAAE,CAAC;YACtD,MAAM,YAAY,GAAG,IAAI,CAAC,OAAO,CAAC,IAAI,EAAE,SAAS,CAAC,CAAC;YACnD,IAAI,YAAY,KAAK,CAAC,CAAC,IAAI,YAAY,GAAG,MAAM,EAAE,CAAC;gBACjD,MAAM;YACR,CAAC;YACD,IAAI,EAAE,CAAC;YACP,SAAS,GAAG,YAAY,GAAG,CAAC,CAAC;QAC/B,CAAC;QACD,MAAM,MAAM,GAAG,MAAM,GAAG,SAAS,CAAC;QAElC,mBAAmB;QACnB,MAAM,UAAU,GAAG,eAAe,CAAC,UAAU,CAAC,CAAC;QAE/C,gFAAgF;QAChF,MAAM,SAAS,GAAG,eAAe,CAAC;QAClC,MAAM,aAAa,GAAG,mBAAmB,IAAI,CAAC,eAAe,CAAC;QAE9D,IAAI,CAAC,IAAI,CAAC;YACR,IAAI,EAAE,OAAO;YACb,UAAU;YACV,MAAM;YACN,IAAI;YACJ,MAAM;YACN,IAAI,EAAE,SAAS;YACf,SAAS;YACT,aAAa;SACd,CAAC,CAAC;IACL,CAAC;IAED,OAAO,IAAI,CAAC;AACd,CAAC;AAED;;GAEG;AACH,SAAS,eAAe,CAAC,UAAkB;IACzC,MAAM,UAAU,GAAG,IAAI,GAAG,EAAkB,CAAC;IAE7C,gEAAgE;IAChE,MAAM,SAAS,GAAG,8DAA8D,CAAC;IAEjF,IAAI,KAA6B,CAAC;IAClC,OAAO,CAAC,KAAK,GAAG,SAAS,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC,KAAK,IAAI,EAAE,CAAC;QACrD,MAAM,IAAI,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;QACtB,MAAM,KAAK,GAAG,KAAK,CAAC,CAAC,CAAC,IAAI,KAAK,CAAC,CAAC,CAAC,IAAI,KAAK,CAAC,CAAC,CAAC,IAAI,EAAE,CAAC;QACrD,UAAU,CAAC,GAAG,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;IAC9B,CAAC;IAED,OAAO,UAAU,CAAC;AACpB,CAAC;AAED;;;;GAIG;AACH,SAAgB,mBAAmB,CACjC,WAAyB,EACzB,WAAmB,EACnB,QAA6B,EAC7B,YAA0B;IAE1B,IAAI,WAAW,KAAK,CAAC,EAAE,CAAC;QACtB,OAAO,CAAC,CAAC,CAAC,iCAAiC;IAC7C,CAAC;IAED,MAAM,MAAM,GAAG,WAAW,CAAC,WAAW,CAAC,CAAC;IACxC,MAAM,MAAM,GAAG,WAAW,CAAC,WAAW,GAAG,CAAC,CAAC,CAAC;IAE5C,iDAAiD;IACjD,MAAM,IAAI,GAAG,QAAQ,CAAC,OAAO,EAAE,CAAC;IAChC,MAAM,WAAW,GAAG,MAAM,CAAC,WAAW,CAAC;IACvC,MAAM,SAAS,GAAG,MAAM,CAAC,SAAS,GAAG,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,SAAS,CAAC,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC;IAExE,wCAAwC;IACxC,MAAM,IAAI,GAAG,YAAY,CAAC,IAAI,CAAC,SAAS,CAAC,WAAW,EAAE,SAAS,CAAC,CAAC,CAAC;IAElE,IAAI,KAAK,GAAG,CAAC,CAAC;IACd,IAAI,aAAa,GAAG,CAAC,CAAC;IACtB,IAAI,WAAW,GAAG,KAAK,CAAC;IAExB,KAAK,MAAM,GAAG,IAAI,IAAI,EAAE,CAAC;QACvB,IAAI,GAAG,CAAC,SAAS,EAAE,CAAC;YAClB,KAAK,EAAE,CAAC;QACV,CAAC;aAAM,IAAI,GAAG,CAAC,aAAa,EAAE,CAAC;YAC7B,kDAAkD;YAClD,MAAM,UAAU,GAAG,YAAY,IAAI,YAAY,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;YAE9D,IAAI,KAAK,KAAK,CAAC,IAAI,GAAG,CAAC,IAAI,KAAK,MAAM,CAAC,IAAI,IAAI,CAAC,UAAU,EAAE,CAAC;gBAC3D,aAAa,EAAE,CAAC;gBAChB,IAAI,WAAW,GAAG,GAAG,CAAC,MAAM,KAAK,MAAM,CAAC,WAAW,EAAE,CAAC;oBACpD,WAAW,GAAG,IAAI,CAAC;oBACnB,MAAM;gBACR,CAAC;YACH,CAAC;QACH,CAAC;aAAM,CAAC;YACN,KAAK,EAAE,CAAC;YACR,kDAAkD;YAClD,MAAM,UAAU,GAAG,YAAY,IAAI,YAAY,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;YAE9D,IAAI,KAAK,KAAK,CAAC,IAAI,GAAG,CAAC,IAAI,KAAK,MAAM,CAAC,IAAI,IAAI,CAAC,UAAU,EAAE,CAAC;gBAC3D,aAAa,EAAE,CAAC;gBAChB,IAAI,WAAW,GAAG,GAAG,CAAC,MAAM,KAAK,MAAM,CAAC,WAAW,EAAE,CAAC;oBACpD,WAAW,GAAG,IAAI,CAAC;oBACnB,MAAM;gBACR,CAAC;YACH,CAAC;QACH,CAAC;IACH,CAAC;IAED,OAAO,WAAW,CAAC,CAAC,CAAC,aAAa,CAAC,CAAC,CAAC,CAAC,CAAC;AACzC,CAAC;AAED;;;GAGG;AACH,SAAgB,kBAAkB,CAChC,QAA6B,EAC7B,WAA6D;IAE7D,MAAM,IAAI,GAAG,QAAQ,CAAC,OAAO,EAAE,CAAC;IAChC,MAAM,OAAO,GAAG,YAAY,CAAC,IAAI,CAAC,CAAC;IAEnC,kCAAkC;IAClC,MAAM,KAAK,GAA+C,EAAE,CAAC;IAC7D,IAAI,gBAAgB,GAAG,CAAC,CAAC;IAEzB,KAAK,MAAM,GAAG,IAAI,OAAO,EAAE,CAAC;QAC1B,IAAI,GAAG,CAAC,SAAS,EAAE,CAAC;YAClB,iBAAiB;YACjB,IAAI,KAAK,CAAC,MAAM,GAAG,CAAC,IAAI,KAAK,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC,IAAI,KAAK,GAAG,CAAC,IAAI,EAAE,CAAC;gBACtE,KAAK,CAAC,GAAG,EAAE,CAAC;gBACZ,IAAI,KAAK,CAAC,MAAM,GAAG,gBAAgB,EAAE,CAAC;oBACpC,gBAAgB,GAAG,KAAK,CAAC,MAAM,CAAC;gBAClC,CAAC;YACH,CAAC;QACH,CAAC;aAAM,IAAI,CAAC,GAAG,CAAC,aAAa,EAAE,CAAC;YAC9B,yDAAyD;YACzD,MAAM,cAAc,GAAG,WAAW,CAAC,gBAAgB,CAAC,CAAC;YAErD,IAAI,cAAc,IAAI,GAAG,CAAC,IAAI,KAAK,cAAc,CAAC,GAAG,EAAE,CAAC;gBACtD,+DAA+D;gBAC/D,IAAI,OAAO,GAAG,KAAK,CAAC;gBAEpB,IAAI,cAAc,CAAC,IAAI,KAAK,SAAS,EAAE,CAAC;oBACtC,4BAA4B;oBAC5B,OAAO,GAAG,GAAG,CAAC,UAAU,CAAC,GAAG,CAAC,MAAM,CAAC,KAAK,cAAc,CAAC,IAAI,CAAC;gBAC/D,CAAC;qBAAM,IAAI,cAAc,CAAC,KAAK,KAAK,SAAS,EAAE,CAAC;oBAC9C,kDAAkD;oBAClD,MAAM,YAAY,GAAG,sBAAsB,CAAC,OAAO,EAAE,GAAG,EAAE,KAAK,CAAC,MAAM,CAAC,CAAC;oBACxE,OAAO,GAAG,YAAY,KAAK,cAAc,CAAC,KAAK,CAAC;gBAClD,CAAC;qBAAM,CAAC;oBACN,gDAAgD;oBAChD,MAAM,YAAY,GAAG,sBAAsB,CAAC,OAAO,EAAE,GAAG,EAAE,KAAK,CAAC,MAAM,CAAC,CAAC;oBACxE,OAAO,GAAG,YAAY,KAAK,CAAC,CAAC;gBAC/B,CAAC;gBAED,IAAI,OAAO,EAAE,CAAC;oBACZ,gBAAgB,EAAE,CAAC;oBACnB,KAAK,CAAC,IAAI,CAAC,EAAE,GAAG,EAAE,SAAS,EAAE,gBAAgB,EAAE,CAAC,CAAC;oBAEjD,yCAAyC;oBACzC,IAAI,gBAAgB,KAAK,WAAW,CAAC,MAAM,EAAE,CAAC;wBAC5C,OAAO,IAAI,MAAM,CAAC,QAAQ,CAAC,GAAG,CAAC,IAAI,EAAE,GAAG,CAAC,MAAM,CAAC,CAAC;oBACnD,CAAC;gBACH,CAAC;YACH,CAAC;QACH,CAAC;IACH,CAAC;IAED,OAAO,SAAS,CAAC;AACnB,CAAC;AAED;;;GAGG;AACH,SAAS,sBAAsB,CAAC,OAAkB,EAAE,SAAkB,EAAE,WAAmB;IACzF,IAAI,KAAK,GAAG,CAAC,CAAC;IACd,IAAI,KAAK,GAAG,CAAC,CAAC;IAEd,KAAK,MAAM,GAAG,IAAI,OAAO,EAAE,CAAC;QAC1B,IAAI,GAAG,CAAC,MAAM,KAAK,SAAS,CAAC,MAAM,EAAE,CAAC;YACpC,OAAO,KAAK,GAAG,CAAC,CAAC;QACnB,CAAC;QAED,IAAI,GAAG,CAAC,SAAS,EAAE,CAAC;YAClB,KAAK,EAAE,CAAC;QACV,CAAC;aAAM,IAAI,CAAC,GAAG,CAAC,aAAa,EAAE,CAAC;YAC9B,KAAK,EAAE,CAAC;YACR,IAAI,KAAK,KAAK,WAAW,GAAG,CAAC,IAAI,GAAG,CAAC,IAAI,KAAK,SAAS,CAAC,IAAI,EAAE,CAAC;gBAC7D,KAAK,EAAE,CAAC;YACV,CAAC;QACH,CAAC;IACH,CAAC;IAED,OAAO,KAAK,GAAG,CAAC,CAAC;AACnB,CAAC","sourcesContent":["import * as vscode from 'vscode';\n\n/**\n * Represents an XML element found at a specific position in the document.\n */\nexport interface XmlElement {\n  name: string;\n  attributes: Map<string, string>;\n  startOffset: number;\n  endOffset: number;\n  startLine: number;\n  startColumn: number;\n}\n\n/**\n * Parse XML/HTML document and find the element path at the given position.\n * Returns an array of elements from root to the target element.\n */\nexport function findElementPathAtPosition(\n  document: vscode.TextDocument,\n  position: vscode.Position\n): XmlElement[] | undefined {\n  const text = document.getText();\n  const offset = document.offsetAt(position);\n\n  console.log(`XPath Parser: Finding element at offset ${offset}, line ${position.line}, char ${position.character}`);\n\n  // Find all opening and closing tags with their positions\n  const tags = parseAllTags(text);\n\n  // Build element tree by matching open/close tags\n  // Strategy: track the stack as we parse, and whenever we find a tag containing\n  // the cursor, record that path. Keep the deepest (most specific) path found.\n  const stack: XmlElement[] = [];\n  let cursorPath: XmlElement[] | undefined;\n\n  for (const tag of tags) {\n    if (tag.isClosing) {\n      // Pop matching opening tag from stack\n      if (stack.length > 0 && stack[stack.length - 1].name === tag.name) {\n        stack.pop();\n      }\n    } else if (tag.isSelfClosing) {\n      // Self-closing tag - check if cursor is within this tag\n      if (offset >= tag.offset && offset <= tag.offset + tag.text.length) {\n        const element: XmlElement = {\n          name: tag.name,\n          attributes: tag.attributes,\n          startOffset: tag.offset,\n          endOffset: tag.offset + tag.text.length,\n          startLine: tag.line,\n          startColumn: tag.column\n        };\n        // Cursor is within this self-closing tag - this is the deepest match so far\n        cursorPath = [...stack.map(e => ({ ...e })), element];\n      }\n    } else {\n      // Opening tag\n      const element: XmlElement = {\n        name: tag.name,\n        attributes: tag.attributes,\n        startOffset: tag.offset,\n        endOffset: -1, // Will be determined by content/closing tag\n        startLine: tag.line,\n        startColumn: tag.column\n      };\n\n      // Check if cursor is within this opening tag itself\n      if (offset >= tag.offset && offset <= tag.offset + tag.text.length) {\n        cursorPath = [...stack.map(e => ({ ...e })), element];\n      }\n\n      // Push to stack regardless (it's an opening tag)\n      stack.push(element);\n    }\n  }\n\n  // If no specific tag matched, check if cursor is within content of any stacked element\n  if (!cursorPath && stack.length > 0) {\n    // Find the deepest element in stack that starts before cursor\n    for (let i = stack.length - 1; i >= 0; i--) {\n      if (offset >= stack[i].startOffset) {\n        cursorPath = stack.slice(0, i + 1).map(e => ({ ...e }));\n        break;\n      }\n    }\n  }\n\n  const path = cursorPath || [];\n\n  console.log(`XPath Parser: Found path with ${path.length} elements: ${path.map(e => e.name).join(' > ')}`);\n  return path.length > 0 ? path : undefined;\n}\n\ninterface TagInfo {\n  name: string;\n  attributes: Map<string, string>;\n  offset: number;\n  line: number;\n  column: number;\n  text: string;\n  isClosing: boolean;\n  isSelfClosing: boolean;\n}\n\n/**\n * Parse all XML/HTML tags from the text and return them in document order.\n */\nfunction parseAllTags(text: string): TagInfo[] {\n  const tags: TagInfo[] = [];\n\n  // Regex to match opening tags, closing tags, and self-closing tags\n  // Matches: <tagname attrs>, </tagname>, <tagname attrs/>\n  const tagRegex = /<\\s*(\\/)?\\s*([a-zA-Z_][\\w:.-]*)\\s*([^>]*?)\\s*(\\/)?>/g;\n\n  let match: RegExpExecArray | null;\n  let line = 0;\n  let lineStart = 0;\n\n  while ((match = tagRegex.exec(text)) !== null) {\n    const fullMatch = match[0];\n    const hasClosingSlash = !!match[1];  // Leading / means </tag>\n    const hasSelfClosingSlash = !!match[4];  // Trailing / means <tag />\n    const tagName = match[2];\n    const attrString = match[3] || '';\n    const offset = match.index;\n\n    // Calculate line and column\n    while (lineStart < text.length && lineStart <= offset) {\n      const newlineIndex = text.indexOf('\\n', lineStart);\n      if (newlineIndex === -1 || newlineIndex > offset) {\n        break;\n      }\n      line++;\n      lineStart = newlineIndex + 1;\n    }\n    const column = offset - lineStart;\n\n    // Parse attributes\n    const attributes = parseAttributes(attrString);\n\n    // Determine tag type: closing tags have leading /, self-closing have trailing /\n    const isClosing = hasClosingSlash;\n    const isSelfClosing = hasSelfClosingSlash && !hasClosingSlash;\n\n    tags.push({\n      name: tagName,\n      attributes,\n      offset,\n      line,\n      column,\n      text: fullMatch,\n      isClosing,\n      isSelfClosing\n    });\n  }\n\n  return tags;\n}\n\n/**\n * Parse attribute string into a Map of name->value pairs.\n */\nfunction parseAttributes(attrString: string): Map<string, string> {\n  const attributes = new Map<string, string>();\n\n  // Match: attrname=\"value\" or attrname='value' or attrname=value\n  const attrRegex = /([a-zA-Z_][\\w:.-]*)\\s*=\\s*(?:\"([^\"]*)\"|'([^']*)'|([^\\s>]*))/g;\n\n  let match: RegExpExecArray | null;\n  while ((match = attrRegex.exec(attrString)) !== null) {\n    const name = match[1];\n    const value = match[2] ?? match[3] ?? match[4] ?? '';\n    attributes.set(name, value);\n  }\n\n  return attributes;\n}\n\n/**\n * Count how many siblings with the same tag name come before this element.\n * Returns 1-based index.\n * Skips elements in the skipElements set when counting siblings.\n */\nexport function computeSiblingIndex(\n  elementPath: XmlElement[],\n  targetIndex: number,\n  document: vscode.TextDocument,\n  skipElements?: Set<string>\n): number {\n  if (targetIndex === 0) {\n    return 1; // Root element is always index 1\n  }\n\n  const target = elementPath[targetIndex];\n  const parent = elementPath[targetIndex - 1];\n\n  // Find all children of parent with the same name\n  const text = document.getText();\n  const parentStart = parent.startOffset;\n  const parentEnd = parent.endOffset > 0 ? parent.endOffset : text.length;\n\n  // Parse tags only within parent's range\n  const tags = parseAllTags(text.substring(parentStart, parentEnd));\n\n  let depth = 0;\n  let sameNameCount = 0;\n  let foundTarget = false;\n\n  for (const tag of tags) {\n    if (tag.isClosing) {\n      depth--;\n    } else if (tag.isSelfClosing) {\n      // Skip counting if this element should be skipped\n      const shouldSkip = skipElements && skipElements.has(tag.name);\n\n      if (depth === 1 && tag.name === target.name && !shouldSkip) {\n        sameNameCount++;\n        if (parentStart + tag.offset === target.startOffset) {\n          foundTarget = true;\n          break;\n        }\n      }\n    } else {\n      depth++;\n      // Skip counting if this element should be skipped\n      const shouldSkip = skipElements && skipElements.has(tag.name);\n\n      if (depth === 1 && tag.name === target.name && !shouldSkip) {\n        sameNameCount++;\n        if (parentStart + tag.offset === target.startOffset) {\n          foundTarget = true;\n          break;\n        }\n      }\n    }\n  }\n\n  return foundTarget ? sameNameCount : 1;\n}\n\n/**\n * Find an element in the document by XPath.\n * Returns the position of the matching element's start tag, or undefined if not found.\n */\nexport function findElementByXPath(\n  document: vscode.TextDocument,\n  parsedXPath: { tag: string; index?: number; name?: string }[]\n): vscode.Position | undefined {\n  const text = document.getText();\n  const allTags = parseAllTags(text);\n\n  // Track element stack as we parse\n  const stack: Array<{ tag: TagInfo; pathIndex: number }> = [];\n  let currentPathIndex = 0;\n\n  for (const tag of allTags) {\n    if (tag.isClosing) {\n      // Pop from stack\n      if (stack.length > 0 && stack[stack.length - 1].tag.name === tag.name) {\n        stack.pop();\n        if (stack.length < currentPathIndex) {\n          currentPathIndex = stack.length;\n        }\n      }\n    } else if (!tag.isSelfClosing) {\n      // Opening tag - check if it matches current path segment\n      const currentSegment = parsedXPath[currentPathIndex];\n\n      if (currentSegment && tag.name === currentSegment.tag) {\n        // Check if this matches the criteria (index or name attribute)\n        let matches = false;\n\n        if (currentSegment.name !== undefined) {\n          // Must match name attribute\n          matches = tag.attributes.get('name') === currentSegment.name;\n        } else if (currentSegment.index !== undefined) {\n          // Must match index - count siblings at this level\n          const siblingIndex = countPrecedingSiblings(allTags, tag, stack.length);\n          matches = siblingIndex === currentSegment.index;\n        } else {\n          // No specific criteria - match first occurrence\n          const siblingIndex = countPrecedingSiblings(allTags, tag, stack.length);\n          matches = siblingIndex === 1;\n        }\n\n        if (matches) {\n          currentPathIndex++;\n          stack.push({ tag, pathIndex: currentPathIndex });\n\n          // Check if we've matched the entire path\n          if (currentPathIndex === parsedXPath.length) {\n            return new vscode.Position(tag.line, tag.column);\n          }\n        }\n      }\n    }\n  }\n\n  return undefined;\n}\n\n/**\n * Count how many siblings with the same name come before this tag at the given depth.\n * Returns 1-based index.\n */\nfunction countPrecedingSiblings(allTags: TagInfo[], targetTag: TagInfo, targetDepth: number): number {\n  let depth = 0;\n  let count = 0;\n\n  for (const tag of allTags) {\n    if (tag.offset === targetTag.offset) {\n      return count + 1;\n    }\n\n    if (tag.isClosing) {\n      depth--;\n    } else if (!tag.isSelfClosing) {\n      depth++;\n      if (depth === targetDepth + 1 && tag.name === targetTag.name) {\n        count++;\n      }\n    }\n  }\n\n  return count + 1;\n}\n"]}