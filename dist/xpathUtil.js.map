{"version":3,"file":"xpathUtil.js","sourceRoot":"","sources":["../src/xpathUtil.ts"],"names":[],"mappings":"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","sourcesContent":["import * as vscode from 'vscode';\nimport { findElementPathAtPosition, computeSiblingIndex as computeXmlSiblingIndex, XmlElement } from './xmlParser';\n\n/**\n * Enumeration of the built‑in XPath formats supported by the extension.\n */\nexport enum XPathFormat {\n  Full = 'full',\n  Compact = 'compact',\n  NamesOnly = 'namesOnly',\n  NamedFull = 'namedFull',\n  NamedCompact = 'namedCompact',\n  Breadcrumb = 'breadcrumb',\n  Custom = 'custom'\n}\n\n/**\n * A segment of an XPath path.  Holds the element name, 1‑based index among\n * siblings of the same name, and optional value of a `name` attribute.\n */\ninterface SegmentInfo {\n  tag: string;\n  index: number;\n  nameAttr?: string;\n}\n\n/**\n * Options for computing XPaths.\n */\nexport interface ComputeOptions {\n  /**\n   * A list of custom format templates.  If specified and the format passed\n   * to `computeXPathForPosition` is `XPathFormat.Custom` these templates\n   * will be used to construct the output.  Each template may include\n   * placeholders `${tag}`, `${index}` and `${name}`.  Undefined variables\n   * are replaced with an empty string.\n   */\n  customTemplates?: string[];\n}\n\n/**\n * Compute an XPath string for a given cursor position.  If the document\n * does not contain symbols provided by the language server, `undefined`\n * will be returned.\n *\n * @param document The text document containing the XML/HTML/XHTML.\n * @param position The position within the document for which to compute the XPath.\n * @param format    The desired output format.\n * @param options   Additional options such as custom format templates.\n */\nexport async function computeXPathForPosition(\n  document: vscode.TextDocument,\n  position: vscode.Position,\n  format: XPathFormat,\n  options: ComputeOptions = {}\n): Promise<string | undefined> {\n  console.log(`XPath Copier: computeXPathForPosition called for ${document.uri.toString()}`);\n\n  // Use direct XML parsing instead of language server\n  const elementPath = findElementPathAtPosition(document, position);\n\n  if (!elementPath || elementPath.length === 0) {\n    console.log('XPath Copier: No element path found for position');\n    return undefined;\n  }\n\n  console.log(`XPath Copier: Found element path with ${elementPath.length} elements`);\n  const segments = computeSegmentsFromElements(elementPath, document);\n  console.log(`XPath Copier: Computed ${segments.length} segments`);\n\n  if (format === XPathFormat.Custom) {\n    const templates = options.customTemplates ?? [];\n    if (templates.length === 0) {\n      return undefined;\n    }\n    const template = templates[0];\n    return buildCustomXPath(segments, template);\n  }\n  return buildXPath(segments, format);\n}\n\n/**\n * Compute the selection range for a given position.  Used to show the\n * element in a Peek view.\n *\n * @param document The text document.\n * @param position The position to find a symbol for.\n */\nexport async function computeSymbolForPosition(\n  document: vscode.TextDocument,\n  position: vscode.Position\n): Promise<vscode.DocumentSymbol | undefined> {\n  const symbols = await vscode.commands.executeCommand<vscode.DocumentSymbol[]>(\n    'vscode.executeDocumentSymbolProvider',\n    document.uri\n  );\n  if (!symbols || symbols.length === 0) {\n    return undefined;\n  }\n  const path = findSymbolPath(symbols, position);\n  return path ? path[path.length - 1] : undefined;\n}\n\n/**\n * Recursively traverse the symbol tree to find the deepest symbol whose\n * range contains the given position.  Returns an array representing the\n * path from the root symbol to the leaf symbol.  If no matching symbol\n * is found the returned value is `undefined`.\n */\nfunction findSymbolPath(\n  symbols: vscode.DocumentSymbol[],\n  position: vscode.Position,\n  ancestors: vscode.DocumentSymbol[] = []\n): vscode.DocumentSymbol[] | undefined {\n  for (const sym of symbols) {\n    if (contains(sym.range, position)) {\n      console.log(`XPath Copier: Found matching symbol: ${sym.name}, children: ${sym.children?.length || 0}, level: ${ancestors.length}`);\n      // Descend into children to find a deeper match.\n      if (sym.children && sym.children.length > 0) {\n        const deeper = findSymbolPath(sym.children, position, [...ancestors, sym]);\n        if (deeper) {\n          console.log(`XPath Copier: Returning deeper path with ${deeper.length} elements`);\n          return deeper;\n        }\n        console.log(`XPath Copier: No deeper match found in children of ${sym.name}`);\n      } else {\n        console.log(`XPath Copier: Symbol ${sym.name} has no children (children=${sym.children})`);\n      }\n      return [...ancestors, sym];\n    }\n  }\n  return undefined;\n}\n\n/**\n * Determine whether a range contains a position.  DocumentSymbol.range\n * includes the entire element start and end tags as well as children.\n */\nfunction contains(range: vscode.Range, position: vscode.Position): boolean {\n  return range.start.isBeforeOrEqual(position) && range.end.isAfterOrEqual(position);\n}\n\n/**\n * Build the list of SegmentInfo objects from XmlElement path.\n * Computes sibling indexes and extracts name attributes.\n */\nfunction computeSegmentsFromElements(\n  elementPath: XmlElement[],\n  document: vscode.TextDocument\n): SegmentInfo[] {\n  const segments: SegmentInfo[] = [];\n  for (let i = 0; i < elementPath.length; i++) {\n    const element = elementPath[i];\n    const index = computeXmlSiblingIndex(elementPath, i, document);\n    const nameAttr = element.attributes.get('name');\n    segments.push({ tag: element.name, index, nameAttr });\n  }\n  return segments;\n}\n\n/**\n * Build the list of SegmentInfo objects for a given symbol path.  This\n * computes the sibling index and reads the `name` attribute value if\n * present.  This function is exported for unit testing.\n */\nexport function computeSegments(\n  symbolPath: vscode.DocumentSymbol[],\n  document: vscode.TextDocument\n): SegmentInfo[] {\n  const segments: SegmentInfo[] = [];\n  for (let i = 0; i < symbolPath.length; i++) {\n    const sym = symbolPath[i];\n    const parent = i > 0 ? symbolPath[i - 1] : undefined;\n    const index = computeSiblingIndex(sym, parent);\n    const nameAttr = extractNameAttribute(document, sym);\n    segments.push({ tag: sym.name, index, nameAttr });\n  }\n  return segments;\n}\n\n/**\n * Compute the 1‑based index of a symbol among its siblings with the same\n * name.  When no parent exists the index is always 1.  Siblings are\n * determined by comparing the ranges of children on the parent.\n */\nfunction computeSiblingIndex(\n  symbol: vscode.DocumentSymbol,\n  parent: vscode.DocumentSymbol | undefined\n): number {\n  if (!parent || !parent.children) {\n    return 1;\n  }\n  // Filter siblings that have the same name and kind as the target\n  const sameNamed = parent.children.filter(\n    (child) => child.name === symbol.name && child.kind === symbol.kind\n  );\n  for (let i = 0; i < sameNamed.length; i++) {\n    const candidate = sameNamed[i];\n    if (rangesEqual(candidate.range, symbol.range)) {\n      return i + 1;\n    }\n  }\n  return 1;\n}\n\n/**\n * Compare two ranges for equality.  Both start and end positions must match.\n */\nfunction rangesEqual(a: vscode.Range, b: vscode.Range): boolean {\n  return a.start.isEqual(b.start) && a.end.isEqual(b.end);\n}\n\n/**\n * Extract the value of the `name` attribute from the start tag of the given\n * element.  Returns `undefined` if no name attribute exists.  This\n * implementation reads a small slice of the document around the symbol’s\n * start tag and applies a regular expression.\n */\nfunction extractNameAttribute(\n  document: vscode.TextDocument,\n  symbol: vscode.DocumentSymbol\n): string | undefined {\n  try {\n    const range = symbol.range;\n    // Limit search to the first 200 characters of the symbol to avoid\n    // scanning large child contents.  The start tag should occur near\n    // the beginning of this range.\n    const start = range.start;\n    const end = start.translate(0, 200);\n    const snippetRange = new vscode.Range(start, end);\n    const snippet = document.getText(snippetRange);\n    const closeIdx = snippet.indexOf('>');\n    const tagContent = closeIdx >= 0 ? snippet.substring(0, closeIdx + 1) : snippet;\n    const m = /\\bname\\s*=\\s*(?:\"([^\"]*)\"|'([^']*)')/i.exec(tagContent);\n    if (m) {\n      return m[1] ?? m[2] ?? undefined;\n    }\n  } catch {\n    // Best effort only\n  }\n  return undefined;\n}\n\n/**\n * Build a string representation of the XPath given the segments and\n * selected format.  Exported for unit testing.\n */\nexport function buildXPath(segments: SegmentInfo[], format: XPathFormat): string {\n  switch (format) {\n    case XPathFormat.Full:\n      return segments.map((seg) => `/${seg.tag}[${seg.index}]`).join('');\n    case XPathFormat.Compact:\n      return segments\n        .map((seg) => `/${seg.tag}${seg.index > 1 ? `[${seg.index}]` : ''}`)\n        .join('');\n    case XPathFormat.NamesOnly:\n      return segments.map((seg) => `/${seg.tag}`).join('');\n    case XPathFormat.NamedFull:\n      // Named Full behaves like Named Compact: include the name attribute when\n      // present and elide indexes equal to 1.  This mirrors the examples in\n      // the specification where no index was shown for EntityDef or Attribute\n      // when a name attribute was present or the element was the first of its\n      // siblings.\n      return segments\n        .map((seg) => {\n          if (seg.nameAttr) {\n            return `/${seg.tag}[@name='${escapeXPathString(seg.nameAttr)}']`;\n          }\n          return seg.index > 1 ? `/${seg.tag}[${seg.index}]` : `/${seg.tag}`;\n        })\n        .join('');\n    case XPathFormat.NamedCompact:\n      return segments\n        .map((seg) => {\n          if (seg.nameAttr) {\n            return `/${seg.tag}[@name='${escapeXPathString(seg.nameAttr)}']`;\n          }\n          return seg.index > 1 ? `/${seg.tag}[${seg.index}]` : `/${seg.tag}`;\n        })\n        .join('');\n    case XPathFormat.Breadcrumb:\n      return segments\n        .map((seg) => {\n          const namePart = seg.nameAttr ? ` (${seg.nameAttr})` : '';\n          return `${seg.tag}${namePart}`;\n        })\n        .join(' > ');\n    default:\n      return segments.map((seg) => `/${seg.tag}`).join('');\n  }\n}\n\n/**\n * Escape single quotes in attribute values for inclusion in XPath strings.\n */\nfunction escapeXPathString(str: string): string {\n  return str.replace(/'/g, \"''\");\n}\n\n/**\n * Construct a custom XPath according to a format template.  Each segment is\n * generated using the provided template and then concatenated.  Variables\n * `${tag}`, `${index}` and `${name}` will be replaced with the actual\n * values from the SegmentInfo.\n */\nfunction buildCustomXPath(segments: SegmentInfo[], template: string): string {\n  return segments\n    .map((seg) => {\n      let segmentStr = template;\n      segmentStr = segmentStr.replace(/\\$\\{tag\\}/g, seg.tag);\n      segmentStr = segmentStr.replace(/\\$\\{index\\}/g, seg.index.toString());\n      segmentStr = segmentStr.replace(/\\$\\{name\\}/g, seg.nameAttr ?? '');\n      return segmentStr;\n    })\n    .join('');\n}\n\n/**\n * Parse an XPath string into an array of descriptors containing tag name,\n * optional index and optional name attribute.  This helper is used by\n * the reverse lookup command.\n */\nexport function parseXPath(xpath: string): { tag: string; index?: number; name?: string }[] {\n  const trimmed = xpath.trim();\n  // Remove leading slash if present\n  const body = trimmed.startsWith('/') ? trimmed.slice(1) : trimmed;\n  if (!body) return [];\n  return body.split('/')\n    .filter((p) => p.length > 0)\n    .map((segment) => {\n      // Matches patterns like Tag[2] or Tag[@name='value'] or Tag\n      const nameMatch = segment.match(/^([^\\[]+)\\[\\s*@name\\s*=\\s*['\"]([^'\"]+)['\"]\\s*\\]$/i);\n      if (nameMatch) {\n        return { tag: nameMatch[1], name: nameMatch[2] };\n      }\n      const idxMatch = segment.match(/^([^\\[]+)\\[(\\d+)\\]$/);\n      if (idxMatch) {\n        return { tag: idxMatch[1], index: parseInt(idxMatch[2], 10) };\n      }\n      return { tag: segment };\n    });\n}\n\n/**\n * Given a symbol tree and a parsed XPath, find a matching DocumentSymbol.\n * Returns the deepest matching symbol if found; otherwise returns undefined.\n */\nexport function findSymbolByXPath(\n  symbols: vscode.DocumentSymbol[],\n  parsed: { tag: string; index?: number; name?: string }[],\n  document: vscode.TextDocument\n): vscode.DocumentSymbol | undefined {\n  let candidates = symbols;\n  let matchedSymbol: vscode.DocumentSymbol | undefined;\n  for (let level = 0; level < parsed.length; level++) {\n    const part = parsed[level];\n    // Filter candidates matching the current part\n    const filtered = candidates.filter((s) => s.name === part.tag);\n    if (filtered.length === 0) {\n      return undefined;\n    }\n    let chosen: vscode.DocumentSymbol | undefined;\n    if (part.name) {\n      // Name attribute specified – choose first child with matching name attribute\n      chosen = filtered.find((sym) => extractNameAttribute(document, sym) === part.name);\n    } else if (typeof part.index === 'number') {\n      // Index specified – choose Nth child with same tag\n      const idx = part.index - 1;\n      if (idx >= 0 && idx < filtered.length) {\n        chosen = filtered[idx];\n      }\n    } else {\n      // No index or name – pick first occurrence\n      chosen = filtered[0];\n    }\n    if (!chosen) {\n      return undefined;\n    }\n    matchedSymbol = chosen;\n    candidates = chosen.children || [];\n  }\n  return matchedSymbol;\n}"]}